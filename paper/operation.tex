\graphicspath{ {./images/} }
\section{Operation of the System}

\todo{@kq: add nicer images}\\
\todo{@kq: list the fields used in messages}\\
\subsection{Fields we saved for messages}
• Message.Channel\\
• Message.User\\
• Message.Text\\
• Message.EventTimestamp\\
• Message.Timestamp (Same as EventTimestamp but in unix timestamp)\\
• Message.SubType (Used in search.html)\\
• Message.PreviousMessage\\

\subsection{Searching for Conversations}

%\todo{1st priority: for @kq: use images to describe how a user uses the system. each image has a caption, in the text expand upon the caption. give a "fake" case study, the user first enters a query, then they look through conversations, then they do blah... etc.}
We first present a small case study that demonstrates some of the user interfaces that are built into PECAN. The homepage (Figure~\ref{fig:homepage}) of PECAN shows statistics about the number of messages that are indexed and several recent messages that have been indexed. One thing to note immediately is that it is possible for PECAN to (optionally) apply the same security considerations as the system that was originally used to send the messages. This allows private messages within a chat system to remain private. We achieve this by providing a pluggable authentication system.~\footnote{For more information about this, please refer to the GitHub repository.} Within the homepage, users may enter queries and filter their query to certain time periods, channels, and other users (depending on the original chat system). PECAN can also be configured to record query logs and fine-grained user interactions with the system, for improving searching for conversations effectiveness and for studying user behaviour in a user study setting.

Once users issue a query to PECAN, they are presented with a conversations results page (CORP), as presented in Figure~\ref{fig:searching}. On this page, users can explore conversations that are relevant to their query. Conversations are ranked according to their relevance to a given query. We describe our approach to scoring conversations in Section~\ref{sec:conv-scoring}. We choose to select five messages before and after a retrieved message to form a conversation. Note that this may result in some conversations with overlapping messages. To address this, we propose to aggregate conversations with overlapping messages. As a result, the CORP may contain conversations with more than ten messages. Our approach to aggregating conversations is described in Section~\ref{sec:conv-agg}.

Finally, each conversation in the CORP can be further explored by viewing messages that occur before or after a conversation. Each conversation in the CORP contains buttons to view messages that occur before or after a conversation. Users are able to cycle through more messages indefinitely in order to fulfil their information need. The interface that users can use to explore these messages is presented in Figure~\ref{fig:traversing}.

\begin{figure}
	\includegraphics[width=\linewidth]{homepage}
	\caption{The homepage of PECAN. Here, users can enter their search query and apply any search filters to refine their search. Statistics about the number of messages that are indexed are also shown, alongside several recently indexed messages.}
	\label{fig:homepage}
\end{figure}

\begin{figure}
	\includegraphics[width=\linewidth]{searching}
	\caption{The CORP page of a response to an example query `party'. Each conversation is ranked in terms of relevance to the input query, similar to contemporary SERPs. Conversations can be explored further by interacting with the `Previous Messages' and `Next Messages' buttons at the start and end of each conversation.}
	\label{fig:searching}
\end{figure}

\begin{figure}
	\includegraphics[width=\linewidth]{traversing}
	\caption{The conversation exploration page that users are presented with after clicking one of the `Previous Messages' or `Next Messages' buttons at the start and end of each conversation on the CORP. Users can continue to load more messages in the conversation indefinitely.}
	\label{fig:traversing}
\end{figure}


\subsection{System Implementation}

PECAN is implemented using the Go programming language. Go was chosen as it has been demonstrated to be an efficient server programming language. This is important as there may considerable overhead in more advanced algorithms than we have proposed that need to be executed at retrieval time (e.g., more complex conversation aggregation or scoring algorithms). For the underlying message storage engine, we use Elasticsearch 7.x. Elasticsearch is a highly scaleable search engine that is capable of ingesting and retrieving documents (in our case messages) in real time.

Of the searching for conversation related research tasks that we raise in Section~\ref{sec:importance}, we have provided baseline implementations of two: conversation aggregation and conversation scoring. The following two sections provide a description of how we implement these methods in PECAN. 

\subsubsection{Conversation Aggregation}
\label{sec:conv-agg}

There are many ways to retrieve conversations instead of messages, for example, one could decide to group messages together based on time, topicality, among others. The default behaviour we provide in PECAN is to aggregate messages into conversations based on the time messages were sent. A high-level overview of this algorithm is provided in Algorithm~\ref{algo:overview}. To form conversations, we first retrieve individual messages given a query. Next, we retrieve the five messages that were sent before and after the original message (including the original message). This is a fast operation within Elasticsearch, and can be done at retrieval time. All ten messages are then combined into a single conversation. One implementation detail we note is that for chat systems that have multiple `channels', we do not merge messages from different channels. This is because we believe that a conversation is tied to the context with which it occurred.

Following the creation of the conversations, we proceed to merge conversations that contain overlapping messages. This process is detailed in Algorithm~\ref{algo:overview}.



\begin{algorithm}
	\SetAlgoLined
	\caption{High-level overview of how conversations are retrieved, scored, and ranked given a query.}
	\label{algo:overview}
	\SetKwInOut{Input}{inputs}
	\SetKwInOut{Output}{output}
	\Input{search query $q$}
	\Output{list of conversations $C$}
	Initialise messages $M$ as the result of executing $q$\\
	Initialise $C\gets\emptyset$\\ 
	\ForEach{$m\in M$}{
		Add to $C$ the list of $k$ surrounding messages of $m$\\
	}
    Merge any overlapping $c\in C$ using Algorithm~\ref{algo:merge}\\
	\Return{C}\end{algorithm}
		
\begin{algorithm}
	\SetAlgoLined
	\caption{Merge Conversations \todo{@kq: simplify this}}
	\label{algo:merge}
	\SetKwInOut{Input}{inputs}
	\SetKwInOut{Output}{output}
	\SetKwProg{MergeConversations}{MergeConversations}{}{}
	\MergeConversations{$(conversations)$}{
		\Input{$conversations$}
		\Output{$C$}
		$mergedConvs \gets []$\\
		$H \gets HashMap$\\
		\ForEach{$conversation \in conversations$}{
			$index \gets H.get(conversation[0].Channel)$\\
			\If{$index \neq null$ and $conversation$ overlap with $mergedConvs[index]$}{
				\ForEach{$message \in conversation$}{
					\If{$message$ is older than $mergedConvs[index]$}{
						$mergedConvs[index].append(message)$
					}
					\ElseIf{$message.Score>0$}{
						\ForEach{$keyMessage \in mergedConvs[index]$}{
							\If{$keyMessage$ and $message$ have same timestamp and content}{
								$keyMessage \gets message$
							}
						}
					}
				}
			}
			\Else{
				$mergedConvs.append(conversation)$
				$H[conversation[0].Channel] = len(C) -1$
			}
		}
		\Return{$mergedConvs$}
	}
\end{algorithm}		
		
\subsubsection{Conversation Scoring}
\label{sec:conv-scoring}

After merging conversations, we rank these conversations based on their scores. Our conversation scoring method exploits the fact that individual messages are scored at retrieval time (i.e., line 1 in Algorithm~\ref{algo:overview}). By default, each conversation inherits the score assigned to the original message that formed the conversation. However, when a conversation is composed by merging two conversations together, we sum the scores of the two messages that overlap.



\subsection{Running a User Study}

\todo{for @hs: description for how to use PECAN in a user study, how to use query logging, interaction logging.}

\subsection{Batch Evaluation}

\todo{for @hs}

%\subsection{Planned Features}
%The current implementation of the system is only a very fundamental template. In the future, we will add more features such as channel filtering, query suggestion, query logging and interaction logging. We will also bring up more research tasks based on this system, such as chat summerisation.
%
%\todo{4th priority: for @kq: channel filtering (in search time), filter by author, attachment search}




